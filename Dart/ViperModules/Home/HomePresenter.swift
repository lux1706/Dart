//
//  HomePresenter.swift
//  Dart
//
//  Created by Tomislav Luketic on 27/06/2020.
//  Copyright (c) 2020 lux. All rights reserved.
//
//  This file was generated by the ğŸ VIPER generator
//

import SVProgressHUD

final class HomePresenter {

  // MARK: - Private properties -

  private unowned let view: HomeViewInterface
  private let interactor: HomeInteractorInterface
  private let wireframe: HomeWireframeInterface
  private var direction: String?
  private var directions: [String] = []
  
  private var stations: [ObjStation] = [] {
    didSet {
      filteredStations = stations
    }
  }
  
  private var stationsData: [ObjStationData] = [] {
    didSet {
      filteredStationsData = stationsData
    }
  }
  
  var filteredStations: [ObjStation] = [] {
    didSet {
      view.reloadStations()
    }
  }
  
  var filteredStationsData: [ObjStationData] = [] {
    didSet {
      view.reloadStationsData()
    }
  }
  
  var selectedStation: ObjStation? {
    didSet {
      view.selectedStationChanged()
    }
  }
  
  // MARK: - Lifecycle -

  init(view: HomeViewInterface,
       interactor: HomeInteractorInterface,
       wireframe: HomeWireframeInterface) {
    self.view = view
    self.interactor = interactor
    self.wireframe = wireframe
  }
}

// MARK: - Extensions -

extension HomePresenter: HomePresenterInterface {
  func getAllStations(type: String?) {
    interactor.getAllStations(type: type) { [unowned self] result in
      SVProgressHUD.dismiss()
      switch result {
      case .success(let stations):
        self.stations = stations
        self.stationSelected(at: 0)
      case .failure(let error):
        self.stations = []
        self.wireframe.showErrorAlert(with: error.localizedDescription)
      }
    }
  }
  
  func filterStations(text: String?) {
    if let text = text, text != "" {
      filteredStations = stations.filter { station in
        station.StationDesc.uppercased().contains(text.uppercased())
      }
    } else {
      filteredStations = stations
    }
  }
  
  func stationSelected(at row: Int) {
    guard
      let station = filteredStations[safe: row]
      else { return }
    selectedStation = station
    getStationData(by: station.StationCode)
  }
  
  func getStationData(by code: String) {
    interactor.getStationData(by: code) { [unowned self] result in
      SVProgressHUD.dismiss()
      switch result {
      case .success(let stationData):
        self.stationsData = stationData
        self.manageDirections()
        self.applyStationsDataFilters()
      case .failure(let error):
        self.stationsData = []
        self.wireframe.showErrorAlert(with: error.localizedDescription)
      }
    }
  }
   
  func directionChanged(index: Int) {
    guard
      let direction = directions[safe: index]
      else { return }
    
    self.direction = direction
    filteredStationsData = filterStationsData(by: direction)
  }
  
  func trainSelected(at row: Int) {
    let stationData = stationsData[row]
    let info = StationAndTrainInfo(Traincode: stationData.Traincode,
                                   stations: stations)
    wireframe.navigate(to: .trainMap(info: info, client: interactor.client))
  }
   
}

private extension HomePresenter {
  func manageDirections() {
    let directions = directionsForStationsData
    if directions != self.directions {
      self.direction = directions.first
      view.stationsDataChanged(containing: directions)
    }
    self.directions = directions
  }
  
  var directionsForStationsData: [String] {
    var directions: [String] = []
    stationsData.forEach { stationData in
      if !directions.contains(stationData.Direction) {
        directions.append(stationData.Direction)
      }
    }
    return directions
  }
  
  func applyStationsDataFilters() {
    if let direction = self.direction {
      filteredStationsData = filterStationsData(by: direction)
    }
  }
  
  func filterStationsData(by direction: String) -> [ObjStationData] {
    return stationsData.filter { $0.Direction == direction }
  }
}

extension Collection {
  public subscript (safe index: Index) -> Element? {
    return indices.contains(index) ? self[index] : nil
  }
}
